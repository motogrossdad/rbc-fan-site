<script>
  async function capturePerlinPaused(stageEl, seed, trackMs, totalMs, onTick){
    const rect = stageEl.getBoundingClientRect();
    const startedAt = performance.now();
    try {
      window.dispatchEvent(new CustomEvent('trueping-capture-start', {
        detail:{ stageSelector:'#'+(stageEl.id||''), seed, startedAt }
      }));
    } catch (_) {}

    let clickedAt = 0;
    const raw = [];
    const events = [];
    const maxMoves = 900;

    const moveH = (e) => {
      const x = e.clientX, y = e.clientY;
      if (x>=rect.left && y>=rect.top && x<=rect.right && y<=rect.bottom){
        // raw samples (for entropy calc)
        raw.push({ t: performance.now(), x: x - rect.left, y: y - rect.top });

        // throttled event log (server uses this too)
        const last = events[events.length-1];
        if (!last || last.type!=='move' || (performance.now() - (last._t||0)) > 16){
          events.push({
            type: 'move',
            dt_ms: Math.round(performance.now() - startedAt),
            x: x - rect.left,
            y: y - rect.top,   // ✅ fixed: was y - rect-top
            _t: performance.now()
          });
          if (events.length > maxMoves) events.splice(1,1);
        }
      }
    };

    const downH = (e) => {
      const x = e.clientX, y = e.clientY;
      if (x>=rect.left && y>=rect.top && x<=rect.right && y<=rect.bottom){
        clickedAt = performance.now();
        events.push({
          type: 'down',
          dt_ms: Math.round(clickedAt - startedAt),
          x: x - rect.left,
          y: y - rect.top     // ✅ keep consistent coords
        });
        try { stageEl.setPointerCapture(e.pointerId); } catch (_){}
      }
    };

    window.addEventListener('mousemove', moveH, { passive:true });
    window.addEventListener('pointermove', moveH, { passive:true });
    window.addEventListener('pointerdown', downH, { passive:true });

    const tEnd = startedAt + totalMs;
    while (performance.now() < tEnd){
      if (typeof onTick === 'function'){
        onTick(Math.ceil((tEnd - performance.now())/1000));
      }
      await new Promise(r => setTimeout(r, 16));
    }

    window.removeEventListener('mousemove', moveH);
    window.removeEventListener('pointermove', moveH);
    window.removeEventListener('pointerdown', downH);

    // Simple entropy estimate from raw samples
    const entropy = (function(samples){
      if (samples.length < 5) return 0;
      let vels=[], turns=[], gaps=[];
      for (let i=1;i<samples.length;i++){
        const a=samples[i-1], b=samples[i];
        const dt=b.t-a.t; if (dt<=0) continue;
        const dx=b.x-a.x, dy=b.y-a.y;
        const v=Math.hypot(dx,dy)/dt; vels.push(v);
        gaps.push(dt);
        if (i>=2){
          const c=samples[i-2];
          const v1x=a.x-c.x, v1y=a.y-c.y;
          const v2x=b.x-a.x, v2y=b.y-a.y;
          const dot=v1x*v2x+v1y*v2y;
          const m1=Math.hypot(v1x,v1y), m2=Math.hypot(v2x,v2y);
          const cos=(m1*m2>0)? Math.max(-1, Math.min(1, dot/(m1*m2))) : 1;
          const ang=Math.acos(cos);
          turns.push(ang);
        }
      }
      const mean=a=>a.reduce((p,c)=>p+c,0)/Math.max(1,a.length);
      const std=a=>{ const m=mean(a); return Math.sqrt(mean(a.map(x=>(x-m)*(x-m)))); };
      const vStd=std(vels), vMean=mean(vels);
      const tStd=std(gaps), tMean=mean(gaps);
      const turnMean=mean(turns);
      let s=0;
      if (vMean>0 && vStd/vMean > 0.2) s += 0.45;
      if (tMean>0 && tStd/tMean > 0.2) s += 0.35;
      if (turnMean > 0.12) s += 0.20;
      return Math.min(1, Math.max(0, s));
    })(raw);

    const reaction_ms = clickedAt ? Math.round(clickedAt - startedAt) : null;

    return {
      challenge: { seed, duration_ms: trackMs, stage: { w: stageEl.clientWidth|0, h: stageEl.clientHeight|0 }, stop_ms: trackMs, total_ms: trackMs + (totalMs - trackMs) },
      signal: { sample_count: raw.length, reaction_ms, entropy },
      trace: { events: events.map(e => e._t ? ({ type:e.type, dt_ms:e.dt_ms, x:e.x, y:e.y }) : e) }
    };
  }
</script>
